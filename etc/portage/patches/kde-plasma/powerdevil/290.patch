From 32489b4df9d084796414483ef1ff3a29cae0ba24 Mon Sep 17 00:00:00 2001
From: Jakob Petsovits <jpetso@petsovits.com>
Date: Wed, 13 Dec 2023 01:04:11 -0500
Subject: [PATCH] Restore battery charge limits on PowerDevil service startup

The code so far did not persist any charge limits, because it
assumed that the firmware would by itself persist them across
reboots. This was true with many ThinkPads, but is not true anymore
with a growing number of modern laptops that rely on user-space
software to remember and restore threshold values.

This commit modifies the KAuth-powered chargethresholdhelper itself.
Calling the setthreshold action will now write a clone of the sysfs
power supply battery threshold files to a persistent config path,
in addition to writing the settings to sysfs itself.

Secondly, there is a new restorethreshold action which combines
parts of getthreshold and setthreshold to (you guessed it):

* read persisted threshold values,
* and restore them where currently active thresholds differ.

Because chargethresholdhelper runs as root, threshold values
are shared among different users of the same machine.
In effect, this makes it idempotent and works very similar to
the previous assumptions of firmware-persisted thresholds.
Barely any changes to PowerDevil itself are needed as a result.

restorethreshold is tame enough to allow unprivileged/passwordless
calls from within PowerDevil::Core service code.

Existing chargethresholdhelper code got refactored a little to
facilitate these changes. On a high level:

* getThresholds() and setThresholds() get an extra argument to
  specify sysfs vs. persistent config directory access.
  A more complex config system is not needed.
* Thresholds are now internally read and set as hashmap of battery
  to (start or stop) threshold value, instead of flat array.
  This helps with applying stored thresholds to current ones,
  and puts in groundwork for per-battery charge limit support.
* getBatteries() only gets called once per action now.
  More efficient but also will fail more loudly in the unlikely
  case of unexpected sysfs directory tree changes.

BUG: 450551
---
 daemon/chargethreshold_helper_actions.actions |   8 +
 daemon/chargethresholdhelper.cpp              | 238 +++++++++++++++---
 daemon/chargethresholdhelper.h                |   1 +
 daemon/powerdevilcore.cpp                     |  14 +-
 daemon/powerdevilcore.h                       |   4 +-
 5 files changed, 226 insertions(+), 39 deletions(-)

diff --git a/daemon/chargethreshold_helper_actions.actions b/daemon/chargethreshold_helper_actions.actions
index 7aeef524c..475314e49 100644
--- a/daemon/chargethreshold_helper_actions.actions
+++ b/daemon/chargethreshold_helper_actions.actions
@@ -211,3 +211,11 @@ Description[zh_CN]=请进行身份验证以设置电池充电限制。
 Description[zh_TW]=認證以設定電池充電限制。
 Policy=auth_admin
 Persistence=session
+
+[org.kde.powerdevil.chargethresholdhelper.restorechargelimit]
+Name=Restore battery charge limits
+Name[de]=Batterie-Ladelimits wiederherstellen
+Description=Authenticate to restore the battery charge limits.
+Description[de]=Authentifizieren, um die Batterie-Ladelimits wiederherzustellen.
+Policy=yes
+PolicyInactive=yes
diff --git a/daemon/chargethresholdhelper.cpp b/daemon/chargethresholdhelper.cpp
index 6c4e0afe1..dcf91705e 100644
--- a/daemon/chargethresholdhelper.cpp
+++ b/daemon/chargethresholdhelper.cpp
@@ -12,8 +12,10 @@
 
 #include <algorithm>
 
+#include <QCoreApplication>
 #include <QDir>
 #include <QFile>
+#include <QStandardPaths>
 
 static const QString s_powerSupplySysFsPath = QStringLiteral("/sys/class/power_supply");
 
@@ -24,6 +26,14 @@ static const QString s_chargeEndThreshold = QStringLiteral("charge_control_end_t
 static const QString s_oldChargeStartThreshold = QStringLiteral("charge_start_threshold");
 static const QString s_oldChargeStopThreshold = QStringLiteral("charge_stop_threshold");
 
+namespace
+{
+enum ThresholdStorage {
+    PowerSupplySysFsStorage,
+    PersistentConfigStorage,
+};
+}
+
 ChargeThresholdHelper::ChargeThresholdHelper(QObject *parent)
     : QObject(parent)
 {
@@ -60,13 +70,32 @@ static QStringList getBatteries()
     return batteries;
 }
 
-static QList<int> getThresholds(const QString &which)
+static QString getThresholdStorageRoot(ThresholdStorage storage)
 {
-    QList<int> thresholds;
+    if (storage == PowerSupplySysFsStorage) {
+        return s_powerSupplySysFsPath;
+    }
+    Q_ASSERT(storage == PersistentConfigStorage);
+
+    // make sure we fill in enough info to get a predictable AppConfigLocation path
+    if (static bool initializedAppName = false; !initializedAppName) {
+        QCoreApplication::setApplicationName(QStringLiteral("powerdevil-chargethresholdhelper"));
+        QCoreApplication::setOrganizationDomain(QStringLiteral("kde.org"));
+        QCoreApplication::setOrganizationName(QStringLiteral("KDE"));
+        initializedAppName = true;
+    }
+    return QStandardPaths::writableLocation(QStandardPaths::AppConfigLocation);
+}
+
+static QHash<QString, int> getThresholds(const QString &which, const QStringList &batteries, ThresholdStorage storage = PowerSupplySysFsStorage)
+{
+    const QString thresholdRoot = getThresholdStorageRoot(storage);
+
+    QHash<QString, int> thresholds;
+    thresholds.reserve(batteries.count());
 
-    const QStringList batteries = getBatteries();
     for (const QString &battery : batteries) {
-        QFile file(s_powerSupplySysFsPath + QLatin1Char('/') + battery + QLatin1Char('/') + which);
+        QFile file(thresholdRoot + QLatin1Char('/') + battery + QLatin1Char('/') + which);
         if (!file.open(QIODevice::ReadOnly)) {
             continue;
         }
@@ -80,17 +109,29 @@ static QList<int> getThresholds(const QString &which)
             continue;
         }
 
-        thresholds.append(threshold);
+        thresholds.insert(battery, threshold);
     }
 
     return thresholds;
 }
 
-static bool setThresholds(const QString &which, int threshold)
+static bool setThresholds(const QString &which, const QHash<QString, int> &thresholds, ThresholdStorage storage = PowerSupplySysFsStorage)
 {
-    const QStringList batteries = getBatteries();
-    for (const QString &battery : batteries) {
-        QFile file(s_powerSupplySysFsPath + QLatin1Char('/') + battery + QLatin1Char('/') + which);
+    const QString thresholdRoot = getThresholdStorageRoot(storage);
+    if (storage == PersistentConfigStorage && !QDir().mkpath(thresholdRoot)) {
+        qWarning() << "Could not create config directory for storing charge thresholds:" << thresholdRoot;
+        return false;
+    }
+
+    for (auto itr = thresholds.cbegin(), end = thresholds.cend(); itr != end; ++itr) {
+        const QString &battery = itr.key();
+        int threshold = itr.value();
+
+        QString batteryDir = thresholdRoot + QLatin1Char('/') + battery;
+        if (storage == PersistentConfigStorage && !QDir().mkpath(batteryDir)) {
+            qWarning() << "Failed to create" << batteryDir << "for storing battery threshold";
+        }
+        QFile file(batteryDir + QLatin1Char('/') + which);
         // TODO should we check the current value before writing the new one or is it clever
         // enough not to shred some chip by writing the same thing again?
         if (!file.open(QIODevice::WriteOnly)) {
@@ -107,16 +148,46 @@ static bool setThresholds(const QString &which, int threshold)
     return true;
 }
 
+bool areThresholdsValid(int startThreshold, bool hasStartThreshold, int stopThreshold, bool hasStopThreshold)
+{
+    if (hasStartThreshold && (startThreshold < 0 || startThreshold > 100)) {
+        return false;
+    } else if (hasStopThreshold && (stopThreshold < 0 || stopThreshold > 100)) {
+        return false;
+    } else if (hasStartThreshold && hasStopThreshold && startThreshold > stopThreshold) {
+        return false;
+    } else if (!hasStartThreshold && !hasStopThreshold) {
+        return false;
+    }
+    return true;
+}
+
+ActionReply getthresholdReply(const QHash<QString, int> &startThresholds, const QHash<QString, int> &stopThresholds)
+{
+    // In the rare case there are multiple batteries with varying charge thresholds, try to use something sensible
+    const int startThreshold = !startThresholds.empty() ? *std::max_element(startThresholds.begin(), startThresholds.end()) : -1;
+    const int stopThreshold = !stopThresholds.empty() ? *std::min_element(stopThresholds.begin(), stopThresholds.end()) : -1;
+
+    ActionReply reply;
+    reply.setData({
+        {QStringLiteral("chargeStartThreshold"), startThreshold},
+        {QStringLiteral("chargeStopThreshold"), stopThreshold},
+    });
+    return reply;
+}
+
 ActionReply ChargeThresholdHelper::getthreshold(const QVariantMap &args)
 {
     Q_UNUSED(args);
 
-    auto startThresholds = getThresholds(s_chargeStartThreshold);
-    auto stopThresholds = getThresholds(s_chargeEndThreshold);
+    const QStringList batteries = getBatteries();
+
+    auto startThresholds = getThresholds(s_chargeStartThreshold, batteries);
+    auto stopThresholds = getThresholds(s_chargeEndThreshold, batteries);
 
     if (startThresholds.isEmpty() && stopThresholds.isEmpty()) {
-        startThresholds = getThresholds(s_oldChargeStartThreshold);
-        stopThresholds = getThresholds(s_oldChargeStopThreshold);
+        startThresholds = getThresholds(s_oldChargeStartThreshold, batteries);
+        stopThresholds = getThresholds(s_oldChargeStopThreshold, batteries);
     }
 
     if (startThresholds.isEmpty() && stopThresholds.isEmpty()) {
@@ -131,16 +202,7 @@ ActionReply ChargeThresholdHelper::getthreshold(const QVariantMap &args)
         return reply;
     }
 
-    // In the rare case there are multiple batteries with varying charge thresholds, try to use something sensible
-    const int startThreshold = !startThresholds.empty() ? *std::max_element(startThresholds.begin(), startThresholds.end()) : -1;
-    const int stopThreshold = !stopThresholds.empty() ? *std::min_element(stopThresholds.begin(), stopThresholds.end()) : -1;
-
-    ActionReply reply;
-    reply.setData({
-        {QStringLiteral("chargeStartThreshold"), startThreshold},
-        {QStringLiteral("chargeStopThreshold"), stopThreshold},
-    });
-    return reply;
+    return getthresholdReply(startThresholds, stopThresholds);
 }
 
 ActionReply ChargeThresholdHelper::setthreshold(const QVariantMap &args)
@@ -153,26 +215,142 @@ ActionReply ChargeThresholdHelper::setthreshold(const QVariantMap &args)
     const int stopThreshold = args.value(QStringLiteral("chargeStopThreshold"), -1).toInt(&hasStopThreshold);
     hasStopThreshold &= stopThreshold != -1;
 
-    if ((hasStartThreshold && (startThreshold < 0 || startThreshold > 100)) || (hasStopThreshold && (stopThreshold < 0 || stopThreshold > 100))
-        || (hasStartThreshold && hasStopThreshold && startThreshold > stopThreshold) || (!hasStartThreshold && !hasStopThreshold)) {
+    if (!areThresholdsValid(startThreshold, hasStartThreshold, stopThreshold, hasStopThreshold)) {
         auto reply = ActionReply::HelperErrorReply(); // is there an "invalid arguments" error?
         reply.setErrorDescription(QStringLiteral("Invalid thresholds provided"));
         return reply;
     }
 
-    if (hasStartThreshold && !(setThresholds(s_chargeStartThreshold, startThreshold) || setThresholds(s_oldChargeStartThreshold, startThreshold))) {
+    const QStringList batteries = getBatteries();
+
+    if (hasStartThreshold) {
+        QHash<QString, int> startThresholds;
+        startThresholds.reserve(batteries.count());
+        for (const QString &battery : batteries) {
+            startThresholds.insert(battery, startThreshold);
+        }
+        if (!(setThresholds(s_chargeStartThreshold, startThresholds) || setThresholds(s_oldChargeStartThreshold, startThresholds))) {
+            auto reply = ActionReply::HelperErrorReply();
+            reply.setErrorDescription(QStringLiteral("Failed to write start charge threshold"));
+            return reply;
+        }
+        if (!setThresholds(s_chargeStartThreshold, startThresholds, PersistentConfigStorage)) {
+            qWarning() << "Successfully assigned start charge threshold, but could not store values for future restoring";
+        }
+    }
+
+    if (hasStopThreshold) {
+        QHash<QString, int> stopThresholds;
+        stopThresholds.reserve(batteries.count());
+        for (const QString &battery : batteries) {
+            stopThresholds.insert(battery, stopThreshold);
+        }
+        if (!(setThresholds(s_chargeEndThreshold, stopThresholds) || setThresholds(s_oldChargeStopThreshold, stopThresholds))) {
+            auto reply = ActionReply::HelperErrorReply();
+            reply.setErrorDescription(QStringLiteral("Failed to write stop charge threshold"));
+            return reply;
+        }
+        if (!setThresholds(s_chargeEndThreshold, stopThresholds, PersistentConfigStorage)) {
+            qWarning() << "Successfully assigned stop charge threshold, but could not store values for future restoring";
+        }
+    }
+
+    return ActionReply();
+}
+
+ActionReply ChargeThresholdHelper::restorethreshold(const QVariantMap &args)
+{
+    Q_UNUSED(args);
+
+    const QStringList batteries = getBatteries();
+
+    // get current thresholds
+
+    auto startThresholds = getThresholds(s_chargeStartThreshold, batteries);
+    auto stopThresholds = getThresholds(s_chargeEndThreshold, batteries);
+    bool useOldNames = false;
+
+    if (startThresholds.isEmpty() && stopThresholds.isEmpty()) {
+        startThresholds = getThresholds(s_oldChargeStartThreshold, batteries);
+        stopThresholds = getThresholds(s_oldChargeStopThreshold, batteries);
+        useOldNames = true;
+    }
+
+    if (startThresholds.isEmpty() && stopThresholds.isEmpty()) {
+        auto reply = ActionReply::HelperErrorReply();
+        reply.setErrorDescription(QStringLiteral("Charge thresholds are not supported by the kernel for this hardware"));
+        return reply;
+    }
+
+    if (!startThresholds.isEmpty() && !stopThresholds.isEmpty() && startThresholds.count() != stopThresholds.count()) {
         auto reply = ActionReply::HelperErrorReply();
-        reply.setErrorDescription(QStringLiteral("Failed to write start charge threshold"));
+        reply.setErrorDescription(QStringLiteral("Charge thresholds are not supported by the kernel for this hardware"));
         return reply;
     }
 
-    if (hasStopThreshold && !(setThresholds(s_chargeEndThreshold, stopThreshold) || setThresholds(s_oldChargeStopThreshold, stopThreshold))) {
+    // get stored thresholds
+
+    const auto storedStartThresholds = getThresholds(s_chargeStartThreshold, batteries, PersistentConfigStorage);
+    const auto storedStopThresholds = getThresholds(s_chargeEndThreshold, batteries, PersistentConfigStorage);
+
+    if (storedStartThresholds.isEmpty() && storedStopThresholds.isEmpty()) {
+        return getthresholdReply(startThresholds, stopThresholds); // nothing to do
+    }
+
+    // use only those stored thresholds that change values of a currently supported battery
+
+    for (const QString &battery : batteries) {
+        const int storedStartThreshold = storedStartThresholds.value(battery, -1);
+        const int storedStopThreshold = storedStopThresholds.value(battery, -1);
+        const bool hasStoredStartThreshold = storedStartThreshold != -1;
+        const bool hasStoredStopThreshold = storedStopThreshold != -1;
+
+        const int currentStartThreshold = startThresholds.value(battery, -1);
+        const int currentStopThreshold = stopThresholds.value(battery, -1);
+
+        const int newStartThreshold = hasStoredStartThreshold ? storedStartThreshold : currentStartThreshold;
+        const int newStopThreshold = hasStoredStopThreshold ? storedStopThreshold : currentStopThreshold;
+        const bool hasNewStartThreshold = newStartThreshold != -1;
+        const bool hasNewStopThreshold = newStopThreshold != -1;
+
+        if (!areThresholdsValid(newStartThreshold, hasNewStartThreshold, newStopThreshold, hasNewStopThreshold)) {
+            startThresholds.remove(battery);
+            stopThresholds.remove(battery);
+            continue;
+        }
+
+        if (hasNewStartThreshold && currentStartThreshold != newStartThreshold) {
+            startThresholds[battery] = newStartThreshold;
+        } else {
+            startThresholds.remove(battery);
+        }
+        if (hasNewStopThreshold && currentStopThreshold != newStopThreshold) {
+            stopThresholds[battery] = newStopThreshold;
+        } else {
+            stopThresholds.remove(battery);
+        }
+    }
+
+    // set thresholds
+
+    if (!startThresholds.isEmpty() && !setThresholds(useOldNames ? s_oldChargeStartThreshold : s_chargeStartThreshold, startThresholds)) {
         auto reply = ActionReply::HelperErrorReply();
-        reply.setErrorDescription(QStringLiteral("Failed to write stop charge threshold"));
+        reply.setErrorDescription(QStringLiteral("Failed to restore start charge threshold"));
         return reply;
     }
 
-    return ActionReply();
+    if (!stopThresholds.isEmpty() && !setThresholds(useOldNames ? s_oldChargeStopThreshold : s_chargeEndThreshold, stopThresholds)) {
+        auto reply = ActionReply::HelperErrorReply();
+        reply.setErrorDescription(QStringLiteral("Failed to restore stop charge threshold"));
+        return reply;
+    }
+
+    // return current (possibly restored) thresholds, same as getthreshold but without some now unnecessary steps
+
+    startThresholds = getThresholds(useOldNames ? s_oldChargeStartThreshold : s_chargeStartThreshold, batteries);
+    stopThresholds = getThresholds(useOldNames ? s_oldChargeStopThreshold : s_chargeEndThreshold, batteries);
+
+    return getthresholdReply(startThresholds, stopThresholds);
 }
 
 KAUTH_HELPER_MAIN("org.kde.powerdevil.chargethresholdhelper", ChargeThresholdHelper)
diff --git a/daemon/chargethresholdhelper.h b/daemon/chargethresholdhelper.h
index fd5a8221e..e3c972895 100644
--- a/daemon/chargethresholdhelper.h
+++ b/daemon/chargethresholdhelper.h
@@ -21,4 +21,5 @@ public:
 public Q_SLOTS:
     ActionReply getthreshold(const QVariantMap &args);
     ActionReply setthreshold(const QVariantMap &args);
+    ActionReply restorethreshold(const QVariantMap &args);
 };
diff --git a/daemon/powerdevilcore.cpp b/daemon/powerdevilcore.cpp
index 8fc976c86..56b7c66f5 100644
--- a/daemon/powerdevilcore.cpp
+++ b/daemon/powerdevilcore.cpp
@@ -69,7 +69,7 @@ Core::Core(QObject *parent)
     });
     discreteGpuJob->start();
 
-    readChargeThreshold();
+    restoreAndReadChargeThreshold();
 }
 
 Core::~Core()
@@ -270,8 +270,6 @@ void Core::reparseConfiguration()
     if (m_lowBatteryNotification && currentChargePercent() > m_globalSettings->batteryLowLevel()) {
         m_lowBatteryNotification->close();
     }
-
-    readChargeThreshold();
 }
 
 QString Core::currentProfile() const
@@ -401,6 +399,10 @@ void Core::loadProfile(bool force)
     if (m_lidController->isLidClosed()) {
         Q_EMIT m_lidController->lidClosedChanged(true);
     }
+
+    // Ideally we'd run this less frequently, e.g. just when starting or resuming the session.
+    // Putting it here though should ensure that we pick it up after e.g. waking up from hibernation.
+    restoreAndReadChargeThreshold();
 }
 
 void Core::onDeviceAdded(const QString &udi)
@@ -925,14 +927,14 @@ void Core::onServiceRegistered(const QString &service)
     }
 }
 
-void Core::readChargeThreshold()
+void Core::restoreAndReadChargeThreshold()
 {
-    KAuth::Action action(QStringLiteral("org.kde.powerdevil.chargethresholdhelper.getthreshold"));
+    KAuth::Action action(QStringLiteral("org.kde.powerdevil.chargethresholdhelper.restorethreshold"));
     action.setHelperId(QStringLiteral("org.kde.powerdevil.chargethresholdhelper"));
     KAuth::ExecuteJob *job = action.execute();
     connect(job, &KJob::result, this, [this, job] {
         if (job->error()) {
-            qCWarning(POWERDEVIL) << "org.kde.powerdevil.chargethresholdhelper.getthreshold failed" << job->errorText();
+            qCWarning(POWERDEVIL) << "org.kde.powerdevil.chargethresholdhelper.restorethreshold failed" << job->errorText();
             return;
         }
 
diff --git a/daemon/powerdevilcore.h b/daemon/powerdevilcore.h
index a35f40fa8..11ee16819 100644
--- a/daemon/powerdevilcore.h
+++ b/daemon/powerdevilcore.h
@@ -63,8 +63,6 @@ public:
     explicit Core(QObject *parent);
     ~Core() override;
 
-    void reloadProfile(int state);
-
     void emitRichNotification(const QString &evid, const QString &title, const QString &message = QString());
 
     void emitNotification(const QString &eventId, const QString &title, const QString &message, const QString &iconName);
@@ -135,7 +133,7 @@ private:
     void updateBatteryNotifications(int percent);
     void triggerCriticalBatteryAction();
 
-    void readChargeThreshold();
+    void restoreAndReadChargeThreshold();
 
     /**
      * Computes the current global charge percentage.
-- 
GitLab

