From 3355d5d6d27e38f06eea1387f88dd053839e7081 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Mon, 23 Oct 2023 21:35:46 +0200
Subject: [PATCH] ROG ally bios check DSD override only for bios <330

---
 sound/pci/hda/cs35l41_hda_property.c | 50 +++++++++++++++++++++++++++-
 1 file changed, 49 insertions(+), 1 deletion(-)

diff --git a/sound/pci/hda/cs35l41_hda_property.c b/sound/pci/hda/cs35l41_hda_property.c
index 59d784b551bbd1..e9dd5b94e70b01 100644
--- a/sound/pci/hda/cs35l41_hda_property.c
+++ b/sound/pci/hda/cs35l41_hda_property.c
@@ -6,7 +6,9 @@
 //
 // Author: Stefan Binding <sbinding@opensource.cirrus.com>
 
+#include <linux/dmi.h>
 #include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
 #include <linux/string.h>
 #include "cs35l41_hda_property.h"
 
@@ -74,6 +76,52 @@ static int hp_vision_acpi_fix(struct cs35l41_hda *cs35l41, struct device *physde
 	return 0;
 }
 
+static int asus_rog_2023_ally_fix(struct cs35l41_hda *cs35l41, struct device *physdev, int id,
+				const char *hid)
+{
+	const char *rog_ally_bios_ver = dmi_get_system_info(DMI_BIOS_VERSION);
+	const char *rog_ally_bios_num = rog_ally_bios_ver + 6; // Dropping the RC71L. part before the number
+	int rog_ally_bios_int;
+	kstrtoint(rog_ally_bios_num, 10, &rog_ally_bios_int);
+	if(rog_ally_bios_int >= 330){
+		printk(KERN_INFO "DSD properties exist in the %d BIOS\n", rog_ally_bios_int);
+		return -ENOENT; //Patch not necessary. Exiting...
+	}
+
+	dev_info(cs35l41->dev, "Adding DSD properties for %s\n", cs35l41->acpi_subsystem_id);
+
+	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
+	int reset_gpio = 0;
+	int spkr_gpio = 2;
+
+	/* check SPI or I2C address to assign the index */
+	cs35l41->index = (id == 0 || id == 0x40) ? 0 : 1;
+	cs35l41->channel_index = 0;
+	hw_cfg->spk_pos = cs35l41->index;
+	hw_cfg->bst_type = CS35L41_EXT_BOOST;
+	hw_cfg->gpio1.func = CS35l41_VSPK_SWITCH;
+	hw_cfg->gpio1.valid = true;
+	hw_cfg->gpio2.func = CS35L41_INTERRUPT;
+	hw_cfg->gpio2.valid = true;
+
+	if (strcmp(cs35l41->acpi_subsystem_id, "10431483") == 0)
+		spkr_gpio = 1;
+	cs35l41->speaker_id = cs35l41_get_speaker_id(physdev, 0, 0, spkr_gpio);
+
+	if (strcmp(cs35l41->acpi_subsystem_id, "10431463") == 0)
+		reset_gpio = 0;
+	else if (strcmp(cs35l41->acpi_subsystem_id, "10431473") == 0
+		|| strcmp(cs35l41->acpi_subsystem_id, "10431483") == 0
+		|| strcmp(cs35l41->acpi_subsystem_id, "10431493") == 0) {
+		reset_gpio = 1;
+	}
+	cs35l41->reset_gpio = gpiod_get_index(physdev, NULL, reset_gpio, GPIOD_OUT_HIGH);
+
+	hw_cfg->valid = true;
+
+	return 0;
+}
+
 /*
  * The CSC3551 is used in almost the entire ASUS ROG laptop range in 2023, this is likely to
  * also include many non ROG labelled laptops. It is also used with either I2C connection or
@@ -132,7 +180,7 @@ static const struct cs35l41_prop_model cs35l41_prop_model_table[] = {
 	{ "CSC3551", "10431483", asus_rog_2023_spkr_id2 }, // ASUS GU603V - spi, reset 1, spkr 1
 	{ "CSC3551", "10431493", asus_rog_2023_spkr_id2 }, // ASUS GV601V - spi, reset gpio 1
 	{ "CSC3551", "10431573", asus_rog_2023_spkr_id2 }, // ASUS GZ301V - spi, reset gpio 0
-	{ "CSC3551", "104317F3", asus_rog_2023_spkr_id2 }, // ASUS ROG ALLY - i2c
+	{ "CSC3551", "104317F3", asus_rog_2023_ally_fix }, // ASUS ROG ALLY - i2c
 	{ "CSC3551", "10431B93", asus_rog_2023_spkr_id2 }, // ASUS G614J - spi, reset gpio 0
 	{ "CSC3551", "10431CAF", asus_rog_2023_spkr_id2 }, // ASUS G634J - spi, reset gpio 0
 	{ "CSC3551", "10431C9F", asus_rog_2023_spkr_id2 }, // ASUS G614JI -spi, reset gpio 0
